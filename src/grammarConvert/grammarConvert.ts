/**
 * This file provides a function, convertGrammarToTypeScriptAst, that converts a
 * marked-up Lezer grammar into a TypeScript file that specifies the full type
 * information for the AST and provides parsing functions to extract it from
 * Lezer syntax nodes.
 *
 * To mark up a Lezer file, add doc comments (/**-style comments) inside rulesets
 * of interest. The doc comment should be on the first line after the curly brace
 * and before any subrules.
 *
 * There are three types of doc comments used for different types of rules.
 *
 * (1)
 * The interface doc comment is the most commonly used and lays out TypeScript
 * AST as interfaces and corresponding parsing functions. This comment is a
 * space-delimeted series of one or more of the following:
 *   -  subtype: A capitalized type corresponding to a type extracted by this rule
 *               and in the order of extraction. The type can be annotated with a
 *               list suffix ([]) if it's an array, or an optional suffix (?) if
 *    Â           it is an optional type
 *   - raw text: Any other text is purely annotational and ported over as a
 *               comment to make reading the AST code easier
 *
 * (2)
 * The union doc comment is used to lay out TypeScript union types, for example
 * when a rule is just a union of possible subrules (statements/expressions are
 * good examples of this). In this case, the doc comment is just the text "|".
 * The corresponding TypeScript AST will be a union type.
 *
 * (3)
 * The value doc comment is used for leaf nodes of trees that are pure values,
 * for example variable names or number literals. In this case the doc comment is
 * just the text ".". The corresponding TypeScript AST will be an interface with
 * no properties.
 *
 * For an example of a properly marked-up Lezer grammar, see ../grammar/poly.grammar
 */

import {
  isFirstUppercased,
  lowercaseFirst,
  uppercaseFirst,
} from "../helpers/string";

/** The header of the generated file */
const FRONTMATTER = `// This file was generated by src/grammarConvert/grammarConvert.ts

import { SyntaxNode } from "@lezer/common";\n\n`;

// The code to insert before the parsing function section
const PARSING_FUNCTION_FRONT = `

/**
* Context is used to track the source program throughout
* the parsing process.
*/
export class Context {
  constructor(readonly program: string) {}

  /**
   * Gets the contents at the specified syntax node
   * @param node The syntax node
   * @returns The text of the program enclosed by this node
   */
  get(node: SyntaxNode): string {
    return this.program.substring(node.from, node.to);
  }

  /**
   * Gets the specified child from the parent node, ensuring it exists
   * @param node The parent node
   * @param child The child selector
   * @returns The child of the parent, or an error if the extraction was
   * unsuccessful (i.e. the getChild call returns null)
   */
  getChild(node: SyntaxNode, child: string): SyntaxNode {
    const childNode = node.getChild(child);
    if (childNode == null) {
      throw new Error(\`Expected child \${child} to be present on \${node.name}\`);
    }
    return childNode;
  }
}\n\n`;

/**
 * Information about a type within a comment
 */
class Subtype {
  /**
   * @param kind Whether the subtype is normal (plain), a list ([]), or optional (?)
   * @param name The name of the subtype
   * @param overrideType If specified, a type that should be used instead
   */
  constructor(
    readonly kind: "plain" | "list" | "optional",
    readonly name: string,
    readonly overrideType?: string,
    readonly extraInfo = ""
  ) {}

  /**
   * @returns The TypeScript type string for this subtype
   */
  toTypeString(): string {
    if (this.overrideType) {
      // If an override type is specified, use it
      return this.overrideType;
    }
    if (this.kind === "list") {
      // Only list returns something different, because optional
      // is covered by the toTypeSuffix method
      return `${this.name}[]`;
    }
    return this.name;
  }

  /**
   * @returns The suffix to use after specifying a property in an object
   */
  toTypeSuffix(): string {
    // Only optional has a type suffix, since TypeScript has a shorthand
    // for potentially undefined props (prop?: value)
    if (this.kind === "optional") return "?";
    return "";
  }

  /**
   *
   * @returns The type formatted for use in an explanatory comment
   */
  toCommentString(): string {
    // Surround the type string by "{}" to make it look nicer
    // Add back in the optional suffix that isn't represented in toTypeString
    return `${this.toTypeString()}${this.kind === "optional" ? "?" : ""}`;
  }

  /**
   * @returns The variable name to use when parsing this particular subtype.
   */
  getName(): string {
    // Format the name for use as a variable
    const mainName = lowercaseFirst(this.name);
    // If it's a list, add the -list suffix
    // (instead of using the plural which could be messy)
    if (this.kind === "list") return `${mainName}List`;
    // If it's optional, specify it's optional- as a prefix
    if (this.kind === "optional") return `optional${uppercaseFirst(this.name)}`;
    // Return the name as-is otherwise
    return mainName;
  }
}

/** A regular expression to parse subtypes */
const SUBTYPE_RE = /([A-Z][a-zA-Z]*)(\[.*\]|\?)?/;

class Comment {
  /** The raw parts of the comment (every space-delimeted feature) */
  readonly parts: string[];

  /** The parsed subtypes and raw text comments */
  readonly parsed: (Subtype | string)[];
  /** A counter tracking occurrences of type names */
  readonly names: { [key: string]: number } = {};
  /** An object tracking presence of list types by name */
  readonly listNames: { [key: string]: boolean } = {};
  /** An object tracking presence of optional types by name */
  readonly optionalNames: { [key: string]: boolean } = {};

  /** An array of all the plain type names (that only occur once) */
  readonly singlePlainNames: string[];
  /** An array of all the list type names (that only occur once) */
  readonly singleListNames: string[];
  /** An array of all the optional type names (that only occur once) */
  readonly singleOptionalNames: string[];
  /** An array of all the type names that occur more than once */
  readonly multiNames: string[];

  /**
   * @param name The name of the rule
   * @param comment The raw text of the comment (excluding the comment characters)
   */
  constructor(public name: string, public comment: string) {
    // Split the comment into space-delimited features
    this.parts = comment
      .split(" ")
      .map((x) => x.trim())
      .filter((x) => x.length > 0);

    // Begin aggregating subtypes and text comments
    this.parsed = [];

    // Go through each part and extract subtypes
    for (const part of this.parts) {
      const partMatch = SUBTYPE_RE.exec(part);
      if (partMatch != null) {
        // A subtype was successfully extracted
        let type: Subtype;
        if (partMatch[2] != null && partMatch[2].startsWith("[")) {
          // Create a list subtype
          type = new Subtype(
            "list",
            partMatch[1],
            undefined,
            partMatch[2].slice(1, -1)
          );
          this.listNames[type.getName()] = true;
        } else if (partMatch[2] === "?") {
          // Create an optional subtype
          type = new Subtype("optional", partMatch[1]);
          this.optionalNames[type.getName()] = true;
        } else {
          // Create a plain subtype
          type = new Subtype("plain", partMatch[1]);
        }
        // Push the parsed subtype
        this.parsed.push(type);
        // Increment the name counter to track duplicates
        this.names[type.getName()] = (this.names[type.getName()] || 0) + 1;
      } else {
        // Push the raw string to track text comments
        this.parsed.push(part);
      }
    }

    // Bin the names
    this.singlePlainNames = Object.entries(this.names)
      // Plain type names that only occur once
      .filter(
        (x) =>
          x[1] === 1 &&
          this.listNames[x[0]] == null &&
          this.optionalNames[x[0]] == null
      )
      .map((x) => x[0]);
    this.singleListNames = Object.entries(this.names)
      // List type names that only occur once
      .filter((x) => x[1] === 1 && this.listNames[x[0]] != null)
      .map((x) => x[0]);
    this.singleOptionalNames = Object.entries(this.names)
      // Optional type names that only occur once
      .filter((x) => x[1] === 1 && this.optionalNames[x[0]] != null)
      .map((x) => x[0]);
    this.multiNames = Object.entries(this.names)
      // Type names that occur more than once
      .filter(
        (x) =>
          x[1] > 1 &&
          this.listNames[x[0]] == null &&
          this.optionalNames[x[0]] == null
      )
      .map((x) => x[0]);
    const leftoverNames = Object.entries(this.names)
      // Type names that are not caught in single plain names,
      // single list names, single optional names, or multi names
      .filter(
        (x) =>
          !this.singlePlainNames.includes(x[0]) &&
          !this.singleListNames.includes(x[0]) &&
          !this.singleOptionalNames.includes(x[0]) &&
          !this.multiNames.includes(x[0])
      );
    if (leftoverNames.length > 0) {
      throw new Error(
        `Uncaught names (${name}): ${leftoverNames.map((x) => x[0]).join(", ")}`
      );
    }
  }

  /**
   *
   * @returns A JS comment text that describes the rule
   */
  toComment() {
    return (
      this.parsed
        // Subtypes are converted to comment strings; raw text is passed straight in
        .map((x) => (typeof x === "string" ? x : x.toCommentString()))
        .join(" ")
    );
  }

  /**
   * @returns The body of a TypeScript interface with all the types laid out
   */
  toInterface() {
    const nameCounts: { [name: string]: number } = {};

    let resultInterface = "";
    for (const type of this.parsed) {
      if (typeof type === "string") continue;
      let name = type.getName();
      if (this.names[name] !== null && this.names[name] >= 2) {
        nameCounts[name] = (nameCounts[name] || 0) + 1;
        name += `${nameCounts[name]}`;
      }
      // Push type part
      resultInterface += `\n  ${name}${type.toTypeSuffix()}: ${type.toTypeString()};`;
    }
    return resultInterface;
  }

  /**
   * @returns The body of a parse function that transforms a Lezer
   * syntax node into a TypeScript object matching the interface
   */
  toParseFunction(): string {
    // Build up the parse function
    let parseFunction = "";

    // Names to be collected for use in the final return statement
    const returnNames: string[] = [];

    // Pare this set down to avoid sharing any multinames twice in
    // the same function
    let remainingMultiNames = this.multiNames;

    // Go through each subtype
    for (const subtype of this.parsed) {
      if (typeof subtype === "string") continue;
      const name = subtype.getName();
      if (this.singlePlainNames.includes(name)) {
        // Parse plain name
        parseFunction += `  const ${name} = context.getChild(node, ${JSON.stringify(
          subtype.name
        )});\n`;
        returnNames.push(
          `${name}: parse${uppercaseFirst(subtype.name)}(context, ${name})`
        );
      } else if (this.singleOptionalNames.includes(name)) {
        // Parse optional name
        parseFunction += `  const ${name} = node.getChild(${JSON.stringify(
          subtype.name
        )});\n`;
        returnNames.push(
          `${name}: ${name} != null ? parse${uppercaseFirst(
            subtype.name
          )}(context, ${name}) : undefined`
        );
      } else if (this.singleListNames.includes(name)) {
        // Parse list
        parseFunction += `  const ${name} = node.getChildren(${JSON.stringify(
          subtype.name
        )})${
          subtype.extraInfo !== "" ? `.slice(${subtype.extraInfo})` : ""
        };\n`;
        returnNames.push(
          `${name}: ${name}.map(${name} => parse${uppercaseFirst(
            subtype.name
          )}(context, ${name}))`
        );
      } else if (remainingMultiNames.includes(name)) {
        const num = this.names[name];
        // Populate parts
        const parts: string[] = [];
        for (let i = 1; i <= num; i++) {
          const newName = `${name}${i}`;
          parts.push(newName);
          returnNames.push(
            `${newName}: parse${uppercaseFirst(
              subtype.name
            )}(context, ${newName})`
          );
        }
        // Extract all the parts in one list destructure operation
        parseFunction += `  const [${parts.join(
          ", "
        )}] = node.getChildren(${JSON.stringify(subtype.name)});\n`;
        // Don't parse multiname again
        remainingMultiNames = remainingMultiNames.filter((x) => x !== name);
      }
    }

    parseFunction += `  return {
    kind: ${JSON.stringify(this.name)},${returnNames
      .map((name) => `\n    ${name},`)
      .join("")}
  };
}`;

    return `${parseFunction}\n\n`;
  }
}

/**
 * A ruleset, which can extract a TypeScript interface and a TypeScript
 * parsing function to convert a Lezer syntax node
 */
class InterfaceRuleset {
  /** Whether the extracted type is at the root of the tree */
  readonly isLeaf: boolean = false;

  /**
   * @param name The name of the ruleset
   * @param comment The parsed comment object for the ruleset
   */
  constructor(readonly name: string, readonly comment: Comment) {
    if (comment.comment === ".") {
      // Transform "." comments; these indicate leaf nodes whose values can
      // be directly extracted as strings
      comment.comment = "";
      comment.parsed.push(new Subtype("plain", "value", "string"));
      this.isLeaf = true;
    }
  }

  /**
   * @returns The TypeScript interface describing the ruleset's type
   */
  toInterface(): string {
    return `${
      // Pull the comment if specified
      this.comment.comment.length > 0
        ? `/** ${this.comment.toComment()} */\n`
        : ""
    }export interface ${this.name} {
  kind: ${
    // Grab the "kind" for all interfaces; this is the discriminated prop
    JSON.stringify(this.name)
  };${
      // Pull the interface body out of the parsed comment
      this.comment.toInterface()
    }
}\n\n`;
  }

  /**
   * @returns The TypeScript function to parse a Lezer syntax node into the
   * appropriate TypeScript object matching the extracted interface
   */
  getParseFunction(): string {
    // The "export function" line
    const header = `export function parse${this.name}(context: Context, node: SyntaxNode): ${this.name} {\n`;

    if (this.isLeaf) {
      // Return a simple extractor for leaf nodes
      // (values are extracted as strings)
      return `${header}  return {
    kind: ${JSON.stringify(this.name)},
    value: context.get(node),
  };
}\n\n`;
    }

    // For non-leaf nodes, grab the more intricate parse function from the comment
    return `${header}${this.comment.toParseFunction()}`;
  }
}

/**
 * A ruleset, which can extract a TypeScript union type and a
 * TypeScript parsing function to convert a Lezer syntax node
 */
class UnionTypeRuleset {
  /**
   *
   * @param originalName The original name of the ruleset (before accommodating
   * the "@isGroup" name)
   * @param name The regularized name of the ruleset (pulling group if specified)
   * @param unions A list of each union type name
   */
  constructor(
    readonly originalName: string,
    readonly name: string,
    readonly unions: string[]
  ) {}

  /**
   * @returns The TypeScript union describing the ruleset's type
   */
  toUnionType(): string {
    return `export type ${this.name} = ${this.unions
      .map(uppercaseFirst)
      .join(" | ")};\nexport const ${lowercaseFirst(
      this.name
    )}Types = [${this.unions
      .map((x) => JSON.stringify(uppercaseFirst(x)))
      .join(", ")}]\n\n`;
  }

  /**
   * @returns The TypeScript function to parse a Lezer syntax node into the
   * appropriate TypeScript object matching the extracted union type
   */
  getParseFunction(): string {
    // The "export function" line
    const header = `export function parse${uppercaseFirst(
      this.name
    )}(context: Context, node: SyntaxNode): ${this.name} {`;

    return `${header}
${this.unions
  .map((union) => {
    // For each union type extract some parsing code
    const typeName = lowercaseFirst(union);
    if (isFirstUppercased(this.originalName)) {
      // If the original name is uppercased, union types are retrieved
      // as child nodes
      return `  const ${typeName} = node.getChild("${union}");
  if (${typeName} != null) return parse${uppercaseFirst(
        typeName
      )}(context, ${typeName});`;
    } else {
      // Otherwise, union types are retrieved if the node name matches
      return `  if (node.name === ${JSON.stringify(union)}) {
    return parse${uppercaseFirst(typeName)}(context, node);
  }`;
    }
  })
  .join("\n")}
  throw new Error(\`Invalid: \${node.name} cannot be parsed as ${this.name}\`);
}\n\n`;
  }
}

/**
 * Converts a marked-up Lezer grammar to a TypeScript AST
 * @param document The raw marked-up Lezer grammar as text
 * @returns The raw converted TypeScript AST code
 */
export function convertGrammarToTypeScriptAst(document: string): string {
  // Always start with the frontmatter
  let typescript = FRONTMATTER;

  // Tack the parsing functions on at the end
  let parsingFunctions = PARSING_FUNCTION_FRONT;

  // Keep track of all types for a unified AST union type at the end.
  const allTypes: string[] = [];

  // Keep track of the position within the document
  let position = 0;
  while (true) {
    // Grab the start of a doc comment (/**)
    const docComment = document.indexOf("/**", position);

    if (docComment === -1) break; // No more nodes found

    // Seek til the end of the doc comment (*/)
    const endComment = document.indexOf("*/", docComment);

    if (endComment === -1) break; // Improper doc comment

    // Extract the comment
    const comment = document.substring(docComment + 3, endComment).trim();

    // Grab the corresponding tag
    const brace = document.lastIndexOf("{", docComment);
    if (brace === -1) break; // No brace found

    // Grab the previous line to extract the rule
    let prevLine = document.lastIndexOf("\n", brace);
    prevLine = prevLine === -1 ? 0 : prevLine; // Start of document maps to 0
    // The rule name comes from the previous line
    let rule = document.substring(prevLine, brace).replace("@top", "").trim();
    // Track the original rule name before regularization
    const originalName = rule;
    // Regularize isGroup
    const groupExtract = /\[@isGroup=(.*)\]/.exec(rule);
    if (groupExtract != null) {
      rule = groupExtract[1];
    }

    if (comment === "|") {
      // Pull out union case
      const endBrace = document.indexOf("}", endComment);
      if (endBrace === -1) break; // Improper rule; abort
      // Grab the raw text of the union types
      const rawUnions = document.substring(endComment + 2, endBrace);
      // Extract union types as a list
      const unions = rawUnions
        .split("|")
        .map((x) => x.trim())
        .filter((x) => x.length > 0);

      // Pull the union type ruleset
      const type = new UnionTypeRuleset(originalName, rule, unions);
      typescript += type.toUnionType();
      // Track the parsing function to add at the end
      parsingFunctions += type.getParseFunction();
    } else {
      // Pull the interface ruleset
      const type = new InterfaceRuleset(rule, new Comment(rule, comment));
      typescript += type.toInterface();
      // Track the parsing function to add at the end
      parsingFunctions += type.getParseFunction();
    }

    // Track the rule
    allTypes.push(rule);

    position = endComment;
  }

  // Tack on the unified AST
  typescript += `export type AST = ${allTypes.join(" | ")};`;

  // Tack on the parsing functions
  typescript += parsingFunctions;

  // Return the collected TypeScript AST code
  return typescript.trim() + "\n";
}
