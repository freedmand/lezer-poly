// This file was generated by src/grammarConvert/grammarConvert.ts

import { SyntaxNode } from "@lezer/common";

/** Statement[] */
export interface Program {
  kind: "Program";
  statementList: Statement[];
}

export type Statement = DeclareStatement | TypeDeclareStatement | DeclareFunctionStatement | DeclareTypeFunctionStatement | AssignStatement | PlusAssignStatement | MinusAssignStatement | TimesAssignStatement | DivideAssignStatement | BlockStatement | IfStatement | ForStatement | ExpressionStatement | FunctionStatement | OperatorFunctionStatement | ClassStatement | ReturnStatement;
export const statementTypes = ["DeclareStatement", "TypeDeclareStatement", "DeclareFunctionStatement", "DeclareTypeFunctionStatement", "AssignStatement", "PlusAssignStatement", "MinusAssignStatement", "TimesAssignStatement", "DivideAssignStatement", "BlockStatement", "IfStatement", "ForStatement", "ExpressionStatement", "FunctionStatement", "OperatorFunctionStatement", "ClassStatement", "ReturnStatement"]

/** Declarator Identifier OptionalType = Expression */
export interface DeclareStatement {
  kind: "DeclareStatement";
  declarator: Declarator;
  identifier: Identifier;
  optionalType: OptionalType;
  expression: Expression;
}

/** type TypeIdentifier OptionalType = Expression */
export interface TypeDeclareStatement {
  kind: "TypeDeclareStatement";
  typeIdentifier: TypeIdentifier;
  optionalType: OptionalType;
  expression: Expression;
}

/** Declarator Identifier ( Param[] ) Expression? ClosureOrBlockStatement */
export interface DeclareFunctionStatement {
  kind: "DeclareFunctionStatement";
  declarator: Declarator;
  identifier: Identifier;
  paramList: Param[];
  optionalExpression?: Expression;
  closureOrBlockStatement: ClosureOrBlockStatement;
}

/** type TypeIdentifier ( Param[] ) Expression? ClosureOrBlockStatement */
export interface DeclareTypeFunctionStatement {
  kind: "DeclareTypeFunctionStatement";
  typeIdentifier: TypeIdentifier;
  paramList: Param[];
  optionalExpression?: Expression;
  closureOrBlockStatement: ClosureOrBlockStatement;
}

export type Declarator = LetDeclarator | VarDeclarator;
export const declaratorTypes = ["LetDeclarator", "VarDeclarator"]

/** let */
export interface LetDeclarator {
  kind: "LetDeclarator";
}

/** var */
export interface VarDeclarator {
  kind: "VarDeclarator";
}

/** Identifier = Expression */
export interface AssignStatement {
  kind: "AssignStatement";
  identifier: Identifier;
  expression: Expression;
}

/** Identifier += Expression */
export interface PlusAssignStatement {
  kind: "PlusAssignStatement";
  identifier: Identifier;
  expression: Expression;
}

/** Identifier -= Expression */
export interface MinusAssignStatement {
  kind: "MinusAssignStatement";
  identifier: Identifier;
  expression: Expression;
}

/** Identifier *= Expression */
export interface TimesAssignStatement {
  kind: "TimesAssignStatement";
  identifier: Identifier;
  expression: Expression;
}

/** Identifier /= Expression */
export interface DivideAssignStatement {
  kind: "DivideAssignStatement";
  identifier: Identifier;
  expression: Expression;
}

/** { Statement[] } */
export interface BlockStatement {
  kind: "BlockStatement";
  statementList: Statement[];
}

export type ClosureOrBlockStatement = ArrowExpressionStatement | BlockStatement;
export const closureOrBlockStatementTypes = ["ArrowExpressionStatement", "BlockStatement"]

export type ClosureOrBlockExpression = ArrowExpression | BlockStatement;
export const closureOrBlockExpressionTypes = ["ArrowExpression", "BlockStatement"]

/** fn Identifier ( Param[] ) Expression? ClosureOrBlockStatement */
export interface FunctionStatement {
  kind: "FunctionStatement";
  identifier: Identifier;
  paramList: Param[];
  optionalExpression?: Expression;
  closureOrBlockStatement: ClosureOrBlockStatement;
}

/** operator OperatorToken ( Param[] ) Expression? ClosureOrBlockStatement */
export interface OperatorFunctionStatement {
  kind: "OperatorFunctionStatement";
  operatorToken: OperatorToken;
  paramList: Param[];
  optionalExpression?: Expression;
  closureOrBlockStatement: ClosureOrBlockStatement;
}

export interface OperatorToken {
  kind: "OperatorToken";
  value: string;
}

/** class Identifier ( Expression ) BlockStatement */
export interface ClassStatement {
  kind: "ClassStatement";
  identifier: Identifier;
  expression: Expression;
  blockStatement: BlockStatement;
}

/** ( Param[] ) Expression? ClosureOrBlockExpression */
export interface ClosureExpression {
  kind: "ClosureExpression";
  paramList: Param[];
  optionalExpression?: Expression;
  closureOrBlockExpression: ClosureOrBlockExpression;
}

/** return Expression? */
export interface ReturnStatement {
  kind: "ReturnStatement";
  optionalExpression?: Expression;
}

/** if Expression BlockStatement */
export interface IfStatement {
  kind: "IfStatement";
  expression: Expression;
  blockStatement: BlockStatement;
}

/** for Expression in Expression BlockStatement */
export interface ForStatement {
  kind: "ForStatement";
  expression1: Expression;
  expression2: Expression;
  blockStatement: BlockStatement;
}

/** Expression */
export interface ExpressionStatement {
  kind: "ExpressionStatement";
  expression: Expression;
}

/** => Expression */
export interface ArrowExpressionStatement {
  kind: "ArrowExpressionStatement";
  expression: Expression;
}

/** => Expression */
export interface ArrowExpression {
  kind: "ArrowExpression";
  expression: Expression;
}

export type Expression = Identifier | Number | String | BinaryExpression | GroupExpression | Negate | MemberExpression | CallExpression | ListExpression | DictionaryExpression | ClosureExpression;
export const expressionTypes = ["Identifier", "Number", "String", "BinaryExpression", "GroupExpression", "Negate", "MemberExpression", "CallExpression", "ListExpression", "DictionaryExpression", "ClosureExpression"]

/** [ Expression[] ] */
export interface ListExpression {
  kind: "ListExpression";
  expressionList: Expression[];
}

/** { DictionaryItem[] } */
export interface DictionaryExpression {
  kind: "DictionaryExpression";
  dictionaryItemList: DictionaryItem[];
}

/** Identifier :? Expression? */
export interface DictionaryItem {
  kind: "DictionaryItem";
  identifier: Identifier;
  optionalExpression?: Expression;
}

/** Expression . Identifier */
export interface MemberExpression {
  kind: "MemberExpression";
  expression: Expression;
  identifier: Identifier;
}

/** Expression ( Arg[] ) */
export interface CallExpression {
  kind: "CallExpression";
  expression: Expression;
  argList: Arg[];
}

/** ( Expression ) */
export interface GroupExpression {
  kind: "GroupExpression";
  expression: Expression;
}

export type BinaryExpression = PlusExpression | MinusExpression | TimesExpression | DivideExpression | EqualityExpression | InequalityExpression | GreaterThanExpression | LessThanExpression | GreaterThanOrEqualExpression | LessThanOrEqualExpression | UnionExpression;
export const binaryExpressionTypes = ["PlusExpression", "MinusExpression", "TimesExpression", "DivideExpression", "EqualityExpression", "InequalityExpression", "GreaterThanExpression", "LessThanExpression", "GreaterThanOrEqualExpression", "LessThanOrEqualExpression", "UnionExpression"]

/** Expression + Expression */
export interface PlusExpression {
  kind: "PlusExpression";
  expression1: Expression;
  expression2: Expression;
}

/** Expression - Expression */
export interface MinusExpression {
  kind: "MinusExpression";
  expression1: Expression;
  expression2: Expression;
}

/** Expression * Expression */
export interface TimesExpression {
  kind: "TimesExpression";
  expression1: Expression;
  expression2: Expression;
}

/** Expression / Expression */
export interface DivideExpression {
  kind: "DivideExpression";
  expression1: Expression;
  expression2: Expression;
}

/** Expression == Expression */
export interface EqualityExpression {
  kind: "EqualityExpression";
  expression1: Expression;
  expression2: Expression;
}

/** Expression != Expression */
export interface InequalityExpression {
  kind: "InequalityExpression";
  expression1: Expression;
  expression2: Expression;
}

/** Expression > Expression */
export interface GreaterThanExpression {
  kind: "GreaterThanExpression";
  expression1: Expression;
  expression2: Expression;
}

/** Expression < Expression */
export interface LessThanExpression {
  kind: "LessThanExpression";
  expression1: Expression;
  expression2: Expression;
}

/** Expression >= Expression */
export interface GreaterThanOrEqualExpression {
  kind: "GreaterThanOrEqualExpression";
  expression1: Expression;
  expression2: Expression;
}

/** Expression <= Expression */
export interface LessThanOrEqualExpression {
  kind: "LessThanOrEqualExpression";
  expression1: Expression;
  expression2: Expression;
}

/** Expression | Expression */
export interface UnionExpression {
  kind: "UnionExpression";
  expression1: Expression;
  expression2: Expression;
}

/** - Expression */
export interface Negate {
  kind: "Negate";
  expression: Expression;
}

export type Param = TypeParam | ValueParam;
export const paramTypes = ["TypeParam", "ValueParam"]

/** type TypeIdentifier */
export interface TypeParam {
  kind: "TypeParam";
  typeIdentifier: TypeIdentifier;
}

/** ParamIdentifier OptionalType Expression? */
export interface ValueParam {
  kind: "ValueParam";
  paramIdentifier: ParamIdentifier;
  optionalType: OptionalType;
  optionalExpression?: Expression;
}

export type ParamIdentifier = ParamValueIdentifierToken | ParamTypeIdentifierToken;
export const paramIdentifierTypes = ["ParamValueIdentifierToken", "ParamTypeIdentifierToken"]

/** ValueIdentifier */
export interface ParamValueIdentifierToken {
  kind: "ParamValueIdentifierToken";
  valueIdentifier: ValueIdentifier;
}

/** TypeIdentifier */
export interface ParamTypeIdentifierToken {
  kind: "ParamTypeIdentifierToken";
  typeIdentifier: TypeIdentifier;
}

/** Identifier? =? Expression */
export interface Arg {
  kind: "Arg";
  optionalIdentifier?: Identifier;
  expression: Expression;
}

export type Identifier = ValueIdentifierToken | TypeIdentifierToken;
export const identifierTypes = ["ValueIdentifierToken", "TypeIdentifierToken"]

/** ValueIdentifier */
export interface ValueIdentifierToken {
  kind: "ValueIdentifierToken";
  valueIdentifier: ValueIdentifier;
}

/** TypeIdentifier */
export interface TypeIdentifierToken {
  kind: "TypeIdentifierToken";
  typeIdentifier: TypeIdentifier;
}

/** : Expression? */
export interface OptionalType {
  kind: "OptionalType";
  optionalExpression?: Expression;
}

/** " StringChunk[] " */
export interface String {
  kind: "String";
  stringChunkList: StringChunk[];
}

export type StringChunk = StringContent | Template;
export const stringChunkTypes = ["StringContent", "Template"]

export interface StringContent {
  kind: "StringContent";
  value: string;
}

/** \[ Expression ] */
export interface Template {
  kind: "Template";
  expression: Expression;
}

export interface ValueIdentifier {
  kind: "ValueIdentifier";
  value: string;
}

export interface TypeIdentifier {
  kind: "TypeIdentifier";
  value: string;
}

export interface Number {
  kind: "Number";
  value: string;
}

export type AST = Program | Statement | DeclareStatement | TypeDeclareStatement | DeclareFunctionStatement | DeclareTypeFunctionStatement | Declarator | LetDeclarator | VarDeclarator | AssignStatement | PlusAssignStatement | MinusAssignStatement | TimesAssignStatement | DivideAssignStatement | BlockStatement | ClosureOrBlockStatement | ClosureOrBlockExpression | FunctionStatement | OperatorFunctionStatement | OperatorToken | ClassStatement | ClosureExpression | ReturnStatement | IfStatement | ForStatement | ExpressionStatement | ArrowExpressionStatement | ArrowExpression | Expression | ListExpression | DictionaryExpression | DictionaryItem | MemberExpression | CallExpression | GroupExpression | BinaryExpression | PlusExpression | MinusExpression | TimesExpression | DivideExpression | EqualityExpression | InequalityExpression | GreaterThanExpression | LessThanExpression | GreaterThanOrEqualExpression | LessThanOrEqualExpression | UnionExpression | Negate | Param | TypeParam | ValueParam | ParamIdentifier | ParamValueIdentifierToken | ParamTypeIdentifierToken | Arg | Identifier | ValueIdentifierToken | TypeIdentifierToken | OptionalType | String | StringChunk | StringContent | Template | ValueIdentifier | TypeIdentifier | Number;

/**
* Context is used to track the source program throughout
* the parsing process.
*/
export class Context {
  constructor(readonly program: string) {}

  /**
   * Gets the contents at the specified syntax node
   * @param node The syntax node
   * @returns The text of the program enclosed by this node
   */
  get(node: SyntaxNode): string {
    return this.program.substring(node.from, node.to);
  }

  /**
   * Gets the specified child from the parent node, ensuring it exists
   * @param node The parent node
   * @param child The child selector
   * @returns The child of the parent, or an error if the extraction was
   * unsuccessful (i.e. the getChild call returns null)
   */
  getChild(node: SyntaxNode, child: string): SyntaxNode {
    const childNode = node.getChild(child);
    if (childNode == null) {
      throw new Error(`Expected child ${child} to be present on ${node.name}`);
    }
    return childNode;
  }
}

export function parseProgram(context: Context, node: SyntaxNode): Program {
  const statementList = node.getChildren("Statement");
  return {
    kind: "Program",
    statementList: statementList.map(statementList => parseStatement(context, statementList)),
  };
}

export function parseStatement(context: Context, node: SyntaxNode): Statement {
  if (node.name === "DeclareStatement") {
    return parseDeclareStatement(context, node);
  }
  if (node.name === "TypeDeclareStatement") {
    return parseTypeDeclareStatement(context, node);
  }
  if (node.name === "DeclareFunctionStatement") {
    return parseDeclareFunctionStatement(context, node);
  }
  if (node.name === "DeclareTypeFunctionStatement") {
    return parseDeclareTypeFunctionStatement(context, node);
  }
  if (node.name === "AssignStatement") {
    return parseAssignStatement(context, node);
  }
  if (node.name === "PlusAssignStatement") {
    return parsePlusAssignStatement(context, node);
  }
  if (node.name === "MinusAssignStatement") {
    return parseMinusAssignStatement(context, node);
  }
  if (node.name === "TimesAssignStatement") {
    return parseTimesAssignStatement(context, node);
  }
  if (node.name === "DivideAssignStatement") {
    return parseDivideAssignStatement(context, node);
  }
  if (node.name === "BlockStatement") {
    return parseBlockStatement(context, node);
  }
  if (node.name === "IfStatement") {
    return parseIfStatement(context, node);
  }
  if (node.name === "ForStatement") {
    return parseForStatement(context, node);
  }
  if (node.name === "ExpressionStatement") {
    return parseExpressionStatement(context, node);
  }
  if (node.name === "FunctionStatement") {
    return parseFunctionStatement(context, node);
  }
  if (node.name === "OperatorFunctionStatement") {
    return parseOperatorFunctionStatement(context, node);
  }
  if (node.name === "ClassStatement") {
    return parseClassStatement(context, node);
  }
  if (node.name === "ReturnStatement") {
    return parseReturnStatement(context, node);
  }
  throw new Error(`Invalid: ${node.name} cannot be parsed as Statement`);
}

export function parseDeclareStatement(context: Context, node: SyntaxNode): DeclareStatement {
  const declarator = context.getChild(node, "Declarator");
  const identifier = context.getChild(node, "Identifier");
  const optionalType = context.getChild(node, "OptionalType");
  const expression = context.getChild(node, "Expression");
  return {
    kind: "DeclareStatement",
    declarator: parseDeclarator(context, declarator),
    identifier: parseIdentifier(context, identifier),
    optionalType: parseOptionalType(context, optionalType),
    expression: parseExpression(context, expression),
  };
}

export function parseTypeDeclareStatement(context: Context, node: SyntaxNode): TypeDeclareStatement {
  const typeIdentifier = context.getChild(node, "TypeIdentifier");
  const optionalType = context.getChild(node, "OptionalType");
  const expression = context.getChild(node, "Expression");
  return {
    kind: "TypeDeclareStatement",
    typeIdentifier: parseTypeIdentifier(context, typeIdentifier),
    optionalType: parseOptionalType(context, optionalType),
    expression: parseExpression(context, expression),
  };
}

export function parseDeclareFunctionStatement(context: Context, node: SyntaxNode): DeclareFunctionStatement {
  const declarator = context.getChild(node, "Declarator");
  const identifier = context.getChild(node, "Identifier");
  const paramList = node.getChildren("Param");
  const optionalExpression = node.getChild("Expression");
  const closureOrBlockStatement = context.getChild(node, "ClosureOrBlockStatement");
  return {
    kind: "DeclareFunctionStatement",
    declarator: parseDeclarator(context, declarator),
    identifier: parseIdentifier(context, identifier),
    paramList: paramList.map(paramList => parseParam(context, paramList)),
    optionalExpression: optionalExpression != null ? parseExpression(context, optionalExpression) : undefined,
    closureOrBlockStatement: parseClosureOrBlockStatement(context, closureOrBlockStatement),
  };
}

export function parseDeclareTypeFunctionStatement(context: Context, node: SyntaxNode): DeclareTypeFunctionStatement {
  const typeIdentifier = context.getChild(node, "TypeIdentifier");
  const paramList = node.getChildren("Param");
  const optionalExpression = node.getChild("Expression");
  const closureOrBlockStatement = context.getChild(node, "ClosureOrBlockStatement");
  return {
    kind: "DeclareTypeFunctionStatement",
    typeIdentifier: parseTypeIdentifier(context, typeIdentifier),
    paramList: paramList.map(paramList => parseParam(context, paramList)),
    optionalExpression: optionalExpression != null ? parseExpression(context, optionalExpression) : undefined,
    closureOrBlockStatement: parseClosureOrBlockStatement(context, closureOrBlockStatement),
  };
}

export function parseDeclarator(context: Context, node: SyntaxNode): Declarator {
  const letDeclarator = node.getChild("LetDeclarator");
  if (letDeclarator != null) return parseLetDeclarator(context, letDeclarator);
  const varDeclarator = node.getChild("VarDeclarator");
  if (varDeclarator != null) return parseVarDeclarator(context, varDeclarator);
  throw new Error(`Invalid: ${node.name} cannot be parsed as Declarator`);
}

export function parseLetDeclarator(context: Context, node: SyntaxNode): LetDeclarator {
  return {
    kind: "LetDeclarator",
  };
}

export function parseVarDeclarator(context: Context, node: SyntaxNode): VarDeclarator {
  return {
    kind: "VarDeclarator",
  };
}

export function parseAssignStatement(context: Context, node: SyntaxNode): AssignStatement {
  const identifier = context.getChild(node, "Identifier");
  const expression = context.getChild(node, "Expression");
  return {
    kind: "AssignStatement",
    identifier: parseIdentifier(context, identifier),
    expression: parseExpression(context, expression),
  };
}

export function parsePlusAssignStatement(context: Context, node: SyntaxNode): PlusAssignStatement {
  const identifier = context.getChild(node, "Identifier");
  const expression = context.getChild(node, "Expression");
  return {
    kind: "PlusAssignStatement",
    identifier: parseIdentifier(context, identifier),
    expression: parseExpression(context, expression),
  };
}

export function parseMinusAssignStatement(context: Context, node: SyntaxNode): MinusAssignStatement {
  const identifier = context.getChild(node, "Identifier");
  const expression = context.getChild(node, "Expression");
  return {
    kind: "MinusAssignStatement",
    identifier: parseIdentifier(context, identifier),
    expression: parseExpression(context, expression),
  };
}

export function parseTimesAssignStatement(context: Context, node: SyntaxNode): TimesAssignStatement {
  const identifier = context.getChild(node, "Identifier");
  const expression = context.getChild(node, "Expression");
  return {
    kind: "TimesAssignStatement",
    identifier: parseIdentifier(context, identifier),
    expression: parseExpression(context, expression),
  };
}

export function parseDivideAssignStatement(context: Context, node: SyntaxNode): DivideAssignStatement {
  const identifier = context.getChild(node, "Identifier");
  const expression = context.getChild(node, "Expression");
  return {
    kind: "DivideAssignStatement",
    identifier: parseIdentifier(context, identifier),
    expression: parseExpression(context, expression),
  };
}

export function parseBlockStatement(context: Context, node: SyntaxNode): BlockStatement {
  const statementList = node.getChildren("Statement");
  return {
    kind: "BlockStatement",
    statementList: statementList.map(statementList => parseStatement(context, statementList)),
  };
}

export function parseClosureOrBlockStatement(context: Context, node: SyntaxNode): ClosureOrBlockStatement {
  const arrowExpressionStatement = node.getChild("ArrowExpressionStatement");
  if (arrowExpressionStatement != null) return parseArrowExpressionStatement(context, arrowExpressionStatement);
  const blockStatement = node.getChild("BlockStatement");
  if (blockStatement != null) return parseBlockStatement(context, blockStatement);
  throw new Error(`Invalid: ${node.name} cannot be parsed as ClosureOrBlockStatement`);
}

export function parseClosureOrBlockExpression(context: Context, node: SyntaxNode): ClosureOrBlockExpression {
  const arrowExpression = node.getChild("ArrowExpression");
  if (arrowExpression != null) return parseArrowExpression(context, arrowExpression);
  const blockStatement = node.getChild("BlockStatement");
  if (blockStatement != null) return parseBlockStatement(context, blockStatement);
  throw new Error(`Invalid: ${node.name} cannot be parsed as ClosureOrBlockExpression`);
}

export function parseFunctionStatement(context: Context, node: SyntaxNode): FunctionStatement {
  const identifier = context.getChild(node, "Identifier");
  const paramList = node.getChildren("Param");
  const optionalExpression = node.getChild("Expression");
  const closureOrBlockStatement = context.getChild(node, "ClosureOrBlockStatement");
  return {
    kind: "FunctionStatement",
    identifier: parseIdentifier(context, identifier),
    paramList: paramList.map(paramList => parseParam(context, paramList)),
    optionalExpression: optionalExpression != null ? parseExpression(context, optionalExpression) : undefined,
    closureOrBlockStatement: parseClosureOrBlockStatement(context, closureOrBlockStatement),
  };
}

export function parseOperatorFunctionStatement(context: Context, node: SyntaxNode): OperatorFunctionStatement {
  const operatorToken = context.getChild(node, "OperatorToken");
  const paramList = node.getChildren("Param");
  const optionalExpression = node.getChild("Expression");
  const closureOrBlockStatement = context.getChild(node, "ClosureOrBlockStatement");
  return {
    kind: "OperatorFunctionStatement",
    operatorToken: parseOperatorToken(context, operatorToken),
    paramList: paramList.map(paramList => parseParam(context, paramList)),
    optionalExpression: optionalExpression != null ? parseExpression(context, optionalExpression) : undefined,
    closureOrBlockStatement: parseClosureOrBlockStatement(context, closureOrBlockStatement),
  };
}

export function parseOperatorToken(context: Context, node: SyntaxNode): OperatorToken {
  return {
    kind: "OperatorToken",
    value: context.get(node),
  };
}

export function parseClassStatement(context: Context, node: SyntaxNode): ClassStatement {
  const identifier = context.getChild(node, "Identifier");
  const expression = context.getChild(node, "Expression");
  const blockStatement = context.getChild(node, "BlockStatement");
  return {
    kind: "ClassStatement",
    identifier: parseIdentifier(context, identifier),
    expression: parseExpression(context, expression),
    blockStatement: parseBlockStatement(context, blockStatement),
  };
}

export function parseClosureExpression(context: Context, node: SyntaxNode): ClosureExpression {
  const paramList = node.getChildren("Param");
  const optionalExpression = node.getChild("Expression");
  const closureOrBlockExpression = context.getChild(node, "ClosureOrBlockExpression");
  return {
    kind: "ClosureExpression",
    paramList: paramList.map(paramList => parseParam(context, paramList)),
    optionalExpression: optionalExpression != null ? parseExpression(context, optionalExpression) : undefined,
    closureOrBlockExpression: parseClosureOrBlockExpression(context, closureOrBlockExpression),
  };
}

export function parseReturnStatement(context: Context, node: SyntaxNode): ReturnStatement {
  const optionalExpression = node.getChild("Expression");
  return {
    kind: "ReturnStatement",
    optionalExpression: optionalExpression != null ? parseExpression(context, optionalExpression) : undefined,
  };
}

export function parseIfStatement(context: Context, node: SyntaxNode): IfStatement {
  const expression = context.getChild(node, "Expression");
  const blockStatement = context.getChild(node, "BlockStatement");
  return {
    kind: "IfStatement",
    expression: parseExpression(context, expression),
    blockStatement: parseBlockStatement(context, blockStatement),
  };
}

export function parseForStatement(context: Context, node: SyntaxNode): ForStatement {
  const [expression1, expression2] = node.getChildren("Expression");
  const blockStatement = context.getChild(node, "BlockStatement");
  return {
    kind: "ForStatement",
    expression1: parseExpression(context, expression1),
    expression2: parseExpression(context, expression2),
    blockStatement: parseBlockStatement(context, blockStatement),
  };
}

export function parseExpressionStatement(context: Context, node: SyntaxNode): ExpressionStatement {
  const expression = context.getChild(node, "Expression");
  return {
    kind: "ExpressionStatement",
    expression: parseExpression(context, expression),
  };
}

export function parseArrowExpressionStatement(context: Context, node: SyntaxNode): ArrowExpressionStatement {
  const expression = context.getChild(node, "Expression");
  return {
    kind: "ArrowExpressionStatement",
    expression: parseExpression(context, expression),
  };
}

export function parseArrowExpression(context: Context, node: SyntaxNode): ArrowExpression {
  const expression = context.getChild(node, "Expression");
  return {
    kind: "ArrowExpression",
    expression: parseExpression(context, expression),
  };
}

export function parseExpression(context: Context, node: SyntaxNode): Expression {
  const identifier = node.getChild("Identifier");
  if (identifier != null) return parseIdentifier(context, identifier);
  const number = node.getChild("Number");
  if (number != null) return parseNumber(context, number);
  const string = node.getChild("String");
  if (string != null) return parseString(context, string);
  const binaryExpression = node.getChild("BinaryExpression");
  if (binaryExpression != null) return parseBinaryExpression(context, binaryExpression);
  const groupExpression = node.getChild("GroupExpression");
  if (groupExpression != null) return parseGroupExpression(context, groupExpression);
  const negate = node.getChild("Negate");
  if (negate != null) return parseNegate(context, negate);
  const memberExpression = node.getChild("MemberExpression");
  if (memberExpression != null) return parseMemberExpression(context, memberExpression);
  const callExpression = node.getChild("CallExpression");
  if (callExpression != null) return parseCallExpression(context, callExpression);
  const listExpression = node.getChild("ListExpression");
  if (listExpression != null) return parseListExpression(context, listExpression);
  const dictionaryExpression = node.getChild("DictionaryExpression");
  if (dictionaryExpression != null) return parseDictionaryExpression(context, dictionaryExpression);
  const closureExpression = node.getChild("ClosureExpression");
  if (closureExpression != null) return parseClosureExpression(context, closureExpression);
  throw new Error(`Invalid: ${node.name} cannot be parsed as Expression`);
}

export function parseListExpression(context: Context, node: SyntaxNode): ListExpression {
  const expressionList = node.getChildren("Expression");
  return {
    kind: "ListExpression",
    expressionList: expressionList.map(expressionList => parseExpression(context, expressionList)),
  };
}

export function parseDictionaryExpression(context: Context, node: SyntaxNode): DictionaryExpression {
  const dictionaryItemList = node.getChildren("DictionaryItem");
  return {
    kind: "DictionaryExpression",
    dictionaryItemList: dictionaryItemList.map(dictionaryItemList => parseDictionaryItem(context, dictionaryItemList)),
  };
}

export function parseDictionaryItem(context: Context, node: SyntaxNode): DictionaryItem {
  const identifier = context.getChild(node, "Identifier");
  const optionalExpression = node.getChild("Expression");
  return {
    kind: "DictionaryItem",
    identifier: parseIdentifier(context, identifier),
    optionalExpression: optionalExpression != null ? parseExpression(context, optionalExpression) : undefined,
  };
}

export function parseMemberExpression(context: Context, node: SyntaxNode): MemberExpression {
  const expression = context.getChild(node, "Expression");
  const identifier = context.getChild(node, "Identifier");
  return {
    kind: "MemberExpression",
    expression: parseExpression(context, expression),
    identifier: parseIdentifier(context, identifier),
  };
}

export function parseCallExpression(context: Context, node: SyntaxNode): CallExpression {
  const expression = context.getChild(node, "Expression");
  const argList = node.getChildren("Arg");
  return {
    kind: "CallExpression",
    expression: parseExpression(context, expression),
    argList: argList.map(argList => parseArg(context, argList)),
  };
}

export function parseGroupExpression(context: Context, node: SyntaxNode): GroupExpression {
  const expression = context.getChild(node, "Expression");
  return {
    kind: "GroupExpression",
    expression: parseExpression(context, expression),
  };
}

export function parseBinaryExpression(context: Context, node: SyntaxNode): BinaryExpression {
  const plusExpression = node.getChild("PlusExpression");
  if (plusExpression != null) return parsePlusExpression(context, plusExpression);
  const minusExpression = node.getChild("MinusExpression");
  if (minusExpression != null) return parseMinusExpression(context, minusExpression);
  const timesExpression = node.getChild("TimesExpression");
  if (timesExpression != null) return parseTimesExpression(context, timesExpression);
  const divideExpression = node.getChild("DivideExpression");
  if (divideExpression != null) return parseDivideExpression(context, divideExpression);
  const equalityExpression = node.getChild("EqualityExpression");
  if (equalityExpression != null) return parseEqualityExpression(context, equalityExpression);
  const inequalityExpression = node.getChild("InequalityExpression");
  if (inequalityExpression != null) return parseInequalityExpression(context, inequalityExpression);
  const greaterThanExpression = node.getChild("GreaterThanExpression");
  if (greaterThanExpression != null) return parseGreaterThanExpression(context, greaterThanExpression);
  const lessThanExpression = node.getChild("LessThanExpression");
  if (lessThanExpression != null) return parseLessThanExpression(context, lessThanExpression);
  const greaterThanOrEqualExpression = node.getChild("GreaterThanOrEqualExpression");
  if (greaterThanOrEqualExpression != null) return parseGreaterThanOrEqualExpression(context, greaterThanOrEqualExpression);
  const lessThanOrEqualExpression = node.getChild("LessThanOrEqualExpression");
  if (lessThanOrEqualExpression != null) return parseLessThanOrEqualExpression(context, lessThanOrEqualExpression);
  const unionExpression = node.getChild("UnionExpression");
  if (unionExpression != null) return parseUnionExpression(context, unionExpression);
  throw new Error(`Invalid: ${node.name} cannot be parsed as BinaryExpression`);
}

export function parsePlusExpression(context: Context, node: SyntaxNode): PlusExpression {
  const [expression1, expression2] = node.getChildren("Expression");
  return {
    kind: "PlusExpression",
    expression1: parseExpression(context, expression1),
    expression2: parseExpression(context, expression2),
  };
}

export function parseMinusExpression(context: Context, node: SyntaxNode): MinusExpression {
  const [expression1, expression2] = node.getChildren("Expression");
  return {
    kind: "MinusExpression",
    expression1: parseExpression(context, expression1),
    expression2: parseExpression(context, expression2),
  };
}

export function parseTimesExpression(context: Context, node: SyntaxNode): TimesExpression {
  const [expression1, expression2] = node.getChildren("Expression");
  return {
    kind: "TimesExpression",
    expression1: parseExpression(context, expression1),
    expression2: parseExpression(context, expression2),
  };
}

export function parseDivideExpression(context: Context, node: SyntaxNode): DivideExpression {
  const [expression1, expression2] = node.getChildren("Expression");
  return {
    kind: "DivideExpression",
    expression1: parseExpression(context, expression1),
    expression2: parseExpression(context, expression2),
  };
}

export function parseEqualityExpression(context: Context, node: SyntaxNode): EqualityExpression {
  const [expression1, expression2] = node.getChildren("Expression");
  return {
    kind: "EqualityExpression",
    expression1: parseExpression(context, expression1),
    expression2: parseExpression(context, expression2),
  };
}

export function parseInequalityExpression(context: Context, node: SyntaxNode): InequalityExpression {
  const [expression1, expression2] = node.getChildren("Expression");
  return {
    kind: "InequalityExpression",
    expression1: parseExpression(context, expression1),
    expression2: parseExpression(context, expression2),
  };
}

export function parseGreaterThanExpression(context: Context, node: SyntaxNode): GreaterThanExpression {
  const [expression1, expression2] = node.getChildren("Expression");
  return {
    kind: "GreaterThanExpression",
    expression1: parseExpression(context, expression1),
    expression2: parseExpression(context, expression2),
  };
}

export function parseLessThanExpression(context: Context, node: SyntaxNode): LessThanExpression {
  const [expression1, expression2] = node.getChildren("Expression");
  return {
    kind: "LessThanExpression",
    expression1: parseExpression(context, expression1),
    expression2: parseExpression(context, expression2),
  };
}

export function parseGreaterThanOrEqualExpression(context: Context, node: SyntaxNode): GreaterThanOrEqualExpression {
  const [expression1, expression2] = node.getChildren("Expression");
  return {
    kind: "GreaterThanOrEqualExpression",
    expression1: parseExpression(context, expression1),
    expression2: parseExpression(context, expression2),
  };
}

export function parseLessThanOrEqualExpression(context: Context, node: SyntaxNode): LessThanOrEqualExpression {
  const [expression1, expression2] = node.getChildren("Expression");
  return {
    kind: "LessThanOrEqualExpression",
    expression1: parseExpression(context, expression1),
    expression2: parseExpression(context, expression2),
  };
}

export function parseUnionExpression(context: Context, node: SyntaxNode): UnionExpression {
  const [expression1, expression2] = node.getChildren("Expression");
  return {
    kind: "UnionExpression",
    expression1: parseExpression(context, expression1),
    expression2: parseExpression(context, expression2),
  };
}

export function parseNegate(context: Context, node: SyntaxNode): Negate {
  const expression = context.getChild(node, "Expression");
  return {
    kind: "Negate",
    expression: parseExpression(context, expression),
  };
}

export function parseParam(context: Context, node: SyntaxNode): Param {
  const typeParam = node.getChild("TypeParam");
  if (typeParam != null) return parseTypeParam(context, typeParam);
  const valueParam = node.getChild("ValueParam");
  if (valueParam != null) return parseValueParam(context, valueParam);
  throw new Error(`Invalid: ${node.name} cannot be parsed as Param`);
}

export function parseTypeParam(context: Context, node: SyntaxNode): TypeParam {
  const typeIdentifier = context.getChild(node, "TypeIdentifier");
  return {
    kind: "TypeParam",
    typeIdentifier: parseTypeIdentifier(context, typeIdentifier),
  };
}

export function parseValueParam(context: Context, node: SyntaxNode): ValueParam {
  const paramIdentifier = context.getChild(node, "ParamIdentifier");
  const optionalType = context.getChild(node, "OptionalType");
  const optionalExpression = node.getChild("Expression");
  return {
    kind: "ValueParam",
    paramIdentifier: parseParamIdentifier(context, paramIdentifier),
    optionalType: parseOptionalType(context, optionalType),
    optionalExpression: optionalExpression != null ? parseExpression(context, optionalExpression) : undefined,
  };
}

export function parseParamIdentifier(context: Context, node: SyntaxNode): ParamIdentifier {
  const paramValueIdentifierToken = node.getChild("ParamValueIdentifierToken");
  if (paramValueIdentifierToken != null) return parseParamValueIdentifierToken(context, paramValueIdentifierToken);
  const paramTypeIdentifierToken = node.getChild("ParamTypeIdentifierToken");
  if (paramTypeIdentifierToken != null) return parseParamTypeIdentifierToken(context, paramTypeIdentifierToken);
  throw new Error(`Invalid: ${node.name} cannot be parsed as ParamIdentifier`);
}

export function parseParamValueIdentifierToken(context: Context, node: SyntaxNode): ParamValueIdentifierToken {
  const valueIdentifier = context.getChild(node, "ValueIdentifier");
  return {
    kind: "ParamValueIdentifierToken",
    valueIdentifier: parseValueIdentifier(context, valueIdentifier),
  };
}

export function parseParamTypeIdentifierToken(context: Context, node: SyntaxNode): ParamTypeIdentifierToken {
  const typeIdentifier = context.getChild(node, "TypeIdentifier");
  return {
    kind: "ParamTypeIdentifierToken",
    typeIdentifier: parseTypeIdentifier(context, typeIdentifier),
  };
}

export function parseArg(context: Context, node: SyntaxNode): Arg {
  const optionalIdentifier = node.getChild("Identifier");
  const expression = context.getChild(node, "Expression");
  return {
    kind: "Arg",
    optionalIdentifier: optionalIdentifier != null ? parseIdentifier(context, optionalIdentifier) : undefined,
    expression: parseExpression(context, expression),
  };
}

export function parseIdentifier(context: Context, node: SyntaxNode): Identifier {
  const valueIdentifierToken = node.getChild("ValueIdentifierToken");
  if (valueIdentifierToken != null) return parseValueIdentifierToken(context, valueIdentifierToken);
  const typeIdentifierToken = node.getChild("TypeIdentifierToken");
  if (typeIdentifierToken != null) return parseTypeIdentifierToken(context, typeIdentifierToken);
  throw new Error(`Invalid: ${node.name} cannot be parsed as Identifier`);
}

export function parseValueIdentifierToken(context: Context, node: SyntaxNode): ValueIdentifierToken {
  const valueIdentifier = context.getChild(node, "ValueIdentifier");
  return {
    kind: "ValueIdentifierToken",
    valueIdentifier: parseValueIdentifier(context, valueIdentifier),
  };
}

export function parseTypeIdentifierToken(context: Context, node: SyntaxNode): TypeIdentifierToken {
  const typeIdentifier = context.getChild(node, "TypeIdentifier");
  return {
    kind: "TypeIdentifierToken",
    typeIdentifier: parseTypeIdentifier(context, typeIdentifier),
  };
}

export function parseOptionalType(context: Context, node: SyntaxNode): OptionalType {
  const optionalExpression = node.getChild("Expression");
  return {
    kind: "OptionalType",
    optionalExpression: optionalExpression != null ? parseExpression(context, optionalExpression) : undefined,
  };
}

export function parseString(context: Context, node: SyntaxNode): String {
  const stringChunkList = node.getChildren("StringChunk");
  return {
    kind: "String",
    stringChunkList: stringChunkList.map(stringChunkList => parseStringChunk(context, stringChunkList)),
  };
}

export function parseStringChunk(context: Context, node: SyntaxNode): StringChunk {
  const stringContent = node.getChild("StringContent");
  if (stringContent != null) return parseStringContent(context, stringContent);
  const template = node.getChild("Template");
  if (template != null) return parseTemplate(context, template);
  throw new Error(`Invalid: ${node.name} cannot be parsed as StringChunk`);
}

export function parseStringContent(context: Context, node: SyntaxNode): StringContent {
  return {
    kind: "StringContent",
    value: context.get(node),
  };
}

export function parseTemplate(context: Context, node: SyntaxNode): Template {
  const expression = context.getChild(node, "Expression");
  return {
    kind: "Template",
    expression: parseExpression(context, expression),
  };
}

export function parseValueIdentifier(context: Context, node: SyntaxNode): ValueIdentifier {
  return {
    kind: "ValueIdentifier",
    value: context.get(node),
  };
}

export function parseTypeIdentifier(context: Context, node: SyntaxNode): TypeIdentifier {
  return {
    kind: "TypeIdentifier",
    value: context.get(node),
  };
}

export function parseNumber(context: Context, node: SyntaxNode): Number {
  return {
    kind: "Number",
    value: context.get(node),
  };
}
