// The Poly grammar specification in Lezer
//
// Note: special documentation comments are used to generate AST
// forming code. See ../grammarConvert/grammarConvert.ts for details.

@precedence { negative @right, times @left, plus @left, dictionary @cut }

@top Program { /** Statement[] */ statement* }

// Statements
statement[@isGroup=Statement] {
  /** | */
  DeclareStatement |
  DeclareTypeStatement |
  BlockStatement |
  ExpressionStatement |
  FunctionStatement |
  ReturnStatement
}

DeclareStatement {
  /** (let|var) Identifier TypeExpression? = Expression */
  makeStatement<(keyword<"let"> | keyword<"var">) Identifier optionalType "=" Expression>
}

DeclareTypeStatement {
  /** type TypeIdentifier TypeExpression? = TypeExpression */
  makeStatement<keyword<"type"> TypeIdentifier optionalType "=" TypeExpression>
}

BlockStatement {
  /** { Statement[] } */
  "{" statement* "}"
}

FunctionStatement {
  /** fn Identifier ( Param[] ) TypeExpression? BlockStatement */
  keyword<"fn"> Identifier "(" params ")" optionalReturnType BlockStatement
}

ReturnStatement {
  /** return Expression? */
  makeStatement<keyword<"return"> Expression?>
}

ExpressionStatement {
  /** Expression */
  makeStatement<Expression>
}

// Expressions
Expression {
  /** | */
  Identifier | Number | String | BinaryExpression | GroupExpression |
  Negate | MemberExpression | CallExpression | ListExpression | DictionaryExpression
}

ListExpression {
  /** [ Expression[] ] */
  "[" commaSep<Expression> "]"
}

DictionaryExpression {
  /** { DictionaryItem[] } */
  !dictionary "{" commaSep<DictionaryItem> "}"
}

DictionaryItem {
  /** Identifier :? Expression? */
  Identifier (":" Expression)?
}

MemberExpression {
  /** Expression . Identifier */
  Expression "." Identifier
}

CallExpression {
  /** Expression ( Arg[] ) */
  Expression "(" args ")"
}

GroupExpression {
  /** ( Expression ) */
  "(" Expression ")"
}

BinaryExpression {
  /** | */
  PlusExpression | MinusExpression | TimesExpression | DivideExpression
}

PlusExpression {
  /** Expression + Expression */
  Expression !plus "+" Expression
}

MinusExpression {
  /** Expression - Expression */
  Expression !plus "-" Expression
}

TimesExpression {
  /** Expression * Expression */
  Expression !times "*" Expression
}

DivideExpression {
  /** Expression / Expression */
  Expression !times "/" Expression
}

Negate {
  /** - Expression */
  !negative "-" Expression
}

// Types
TypeExpression {
  /** | */
  TypeIdentifier | Number | String | UnionType
}

UnionType {
  /** TypeExpression | TypeExpression */
  (TypeExpression !plus "|" TypeExpression)
}

// Miscellaneous
Param {
  /** Identifier TypeExpression? Expression? */
  Identifier optionalType optionalDefault
}

Arg {
  /** Identifier? =? Expression */
  (Identifier "=")? Expression
}

optionalType {
  (":" TypeExpression)?
}

optionalReturnType {
  ("->" TypeExpression)?
}

optionalDefault {
  ("=" Expression)?
}

params {
  commaSep<Param>
}

args {
  commaSep<Arg>
}

// Skip / strings
@skip {
  whitespace
}

@skip {} {
  String {
    /** " StringChunk[] " */
    '"' StringChunk* '"'
  }
}

StringChunk {
  /** | */
  StringContent | Template
}

StringContent {
  /** . */
  char
}

Template {
  /** \[ Expression ] */
  "\\[" Expression "]"
}

// Utils
makeStatement<content> { content ";" }
commaSep1<item> { item ("," item)* }
commaSep<item> { commaSep1<item>? }
keyword<content> { @specialize[@name={content}]<Identifier, content> }

@tokens {
  Identifier { /** . */ "@"? @asciiLetter+ }
  TypeIdentifier { /** . */ "@"? @asciiLetter+ }
  Number { /** . */ @digit+ }
  whitespace { @whitespace+ }
  char { ($[\u{20}\u{21}\u{23}-\u{5b}\u{5d}-\u{10ffff}] | "\\" esc)+ }
  esc  { $["\\\/bfnrt] | "u" hex hex hex hex }
  hex  { $[0-9a-fA-F] }
  "+" "-" "*" "/" "[" "]" "{" "}" "\\["
}

@external propSource polyHighlighting from "../grammar/propSource.js"
