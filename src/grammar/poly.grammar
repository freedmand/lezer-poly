// The Poly grammar specification in Lezer
//
// Note: special documentation comments are used to generate AST
// forming code. See ../grammarConvert/grammarConvert.ts for details.

@precedence { negative @right, times @left, plus @left }

@top Program { /** Statement[] */ statement* }

// Statements
statement[@isGroup=Statement] {
  /** | */
  DeclareStatement |
  BlockStatement |
  ExpressionStatement |
  FunctionStatement |
  ReturnStatement
}

DeclareStatement {
  /** let Identifier TypeExpression? = Expression */
  makeStatement<keyword<"let"> Identifier optionalType "=" Expression>
}

BlockStatement {
  /** { Statement[] } */
  "{" statement* "}"
}

FunctionStatement {
  /** fn Identifier ( Arg[] ) BlockStatement */
  keyword<"fn"> Identifier "(" args ")" BlockStatement
}

ReturnStatement {
  /** return Expression? */
  makeStatement<keyword<"return"> Expression?>
}

ExpressionStatement {
  /** Expression */
  makeStatement<Expression>
}

// Expressions
Expression {
  /** | */
  Identifier | Number | String | BinaryExpression | GroupExpression |
  Negate
}

GroupExpression {
  /** ( Expression ) */
  "(" Expression ")"
}

BinaryExpression {
  /** | */
  PlusExpression | MinusExpression | TimesExpression | DivideExpression
}

PlusExpression {
  /** Expression + Expression */
  Expression !plus "+" Expression
}

MinusExpression {
  /** Expression - Expression */
  Expression !plus "-" Expression
}

TimesExpression {
  /** Expression * Expression */
  Expression !times "*" Expression
}

DivideExpression {
  /** Expression / Expression */
  Expression !times "/" Expression
}

Negate {
  /** - Expression */
  !negative "-" Expression
}

// Types
TypeExpression {
  /** | */
  Identifier | Number | String | UnionType
}

UnionType {
  /** TypeExpression | TypeExpression */
  (TypeExpression !plus "|" TypeExpression)
}

// Miscellaneous
Arg {
  /** Identifier TypeExpression? */
  Identifier optionalType
}

optionalType {
  (":" TypeExpression)?
}

args {
  commaSep<Arg>
}

// Skip / strings
@skip {
  whitespace
}

@skip {} {
  String {
    /** " StringChunk[] " */
    '"' StringChunk* '"'
  }
}

StringChunk {
  /** | */
  StringContent | Template
}

StringContent {
  /** . */
  char
}

Template {
  /** \[ Expression ] */
  "\\[" Expression "]"
}

// Utils
makeStatement<content> { content ";" }
commaSep1<item> { item ("," item)* }
commaSep<item> { commaSep1<item>? }
keyword<content> { @specialize[@name={content}]<Identifier, content> }

@tokens {
  Identifier { /** . */ @asciiLetter+ }
  Number { /** . */ @digit+ }
  whitespace { @whitespace+ }
  char { ($[\u{20}\u{21}\u{23}-\u{5b}\u{5d}-\u{10ffff}] | "\\" esc)+ }
  esc  { $["\\\/bfnrt] | "u" hex hex hex hex }
  hex  { $[0-9a-fA-F] }
  "+" "-" "*" "/" "[" "]" "{" "}" "\\["
}

@external propSource polyHighlighting from "../grammar/propSource"
